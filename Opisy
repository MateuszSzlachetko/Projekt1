Sortowanie jest jednym z podstawowych problemów informatyki, w ogólności polega na uporządkowaniu danych ze zbioru względem przyjętego klucza. Dla naszego przypadku sprowadza się do układania kolejnych wartości liczbowych, od najmniejszego do największego elementu. Cele takiej operacji mogą być różne, dlatego w zależności od tego co potrzebujemy, jesteśmy w stanie dobrać odpowiedni alogrytm sortowania. Różnią się one pomiędzy sobą złożonością obliczeniową, która przekłada się bezpośrednio na czas sortowania, ale i tym ile pamięci wykorzystują w danym procesie. Dodatkowo, algorytmy możemy klasyfikować jako stabilne, bądź niestabilne, w zależności od tego, czy elementy o tej samej wartości znajdujące się w tablicy wejściowej w danej kolejności, będą w takiej samej kolejności w tablicy wyjściowej.



Quick sort
Działanie "sortowania szybkiego" jako algorytmu rekurencyjnego polega na wybraniu jednego elementu z tablicy ( w moim przypadku był to ostatni element), który zostaje określony jako tzw. pivot.
Następnie przechodząc przez zbiór do posortowania, kolejne elementy porównujemy z naszym pivotem i elementy mniejsze przenosimy do lewej części tablicy, a elementy większe do prawej.
Po tej operacji na naszych dwóch wydzielonych partycjach, lewej z mniejszymi elementami, prawej z większymi elementami, wywołujemy ponownie algorytm sortowania i rekurencyjnie sortujemy w ten sposób wszystkie elementy.

Przenoszenie elementów tablicy odbywa się w czasie liniowym. W zależności od tego ile wystąpi rekurencyjnych wywołań naszej funkcji, złożoność czasowa wyniesie optymistycznie=średnio- O(n logn) lub pesymistycznie O(n^2). Wynika to z tego, że w przypadku optymistycznym tablica zostanie podzielona na pół, wtedy głębokość drzewa wywołań określa zależność log n, gdzie n to liczba elementów tablicy(Udowodniono, że taki sam rząd złożoności wystąpi w przypadku średnim). Pesymistycznie jednak, gdy nasz pivot zawsze znajduje się na brzegu tablicy, przy każdym kolejnym wywołaniu liczba elementów do posortowania jest tylko o 1 mniejsza, co za tym idzie funkcja wywoła się n razy, gdzie n to liczba elementów tablicy.

Merge sort
Algorytm sortowania "przez scalanie" polega na podziale naszej wejściowej tablicy nieuporządkowanych elementów, aż do uzyskania tablic posortowanych, które następnie łączone są w tablice wyjściową, już z posortowanymi elementami. Najprostszą posortowaną tablicą, jest tablica złożona z jednego elementu. Algorytm rekurencyjnie rozbija kolejne podtablice na ich mniejsze, równe do co ilości elementów odpowiedniki, aż uzyskamy tablice złożone z samych posortowanych elementów, wtedy kolejno porównuje ze sobą elementy z sub tablic i wstawia je do naszej początkowej tablicy.

Złożoność obliczeniowa dla algorytmu merge sort wynosi O(n logn) dla każdego przypadku, niezależnie od danych wejściowych, wynika to z tego, że głębokość drzewa wywołań określa zależność log n, a ilość porównań elementów ma liniowy czas trawania n . Nie występuje w nim więc przypadek pesymistyczny taki jak w Quick sort.

Intro sort
"Sortowanie introspektywne" jest hybrydowym algorytmem sortowania, który składa się z 3 algorytmów. Sortowania szybkiego, przez kopcowanie i przez wstawianie. Takie połączenie pozwala zachować średnią złożoność czasową na poziomie O(n logn) przy braku wystąpienia pesymistycznej wersji złożoności charakterystycznej dla Quick sort. Przy założeniu maksymalnej ilości rekurencyjnych wywołań dla quicksort, po zmniejszeniu ilości przejść do 0, algorytm zaczyna sortować używając algorytmu heapsort, i od pewnej ustalonej ilości elementów używa introsort. Przy implementacji, bez użycia introsort, algorytm stawał się nieefektywny, dlatego potrzebna jest kombinacja właśnie tych 3 algorytmów. Jego zaletą jest zachowanie właściwości quicksort, przy czym nie jest wrażliwy na uporządkowanie danych na wejściu i jego czas wywołania nie zmienia się dla uporządkowanych zbiorów.
